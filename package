#! /usr/bin/env python3

import os
import sh
import yaml


def detect_if_we_have_run_package_before():
    """
    Using a marker file, have we previously ran the package script?
    """
    INDICATOR_FILE_NAME = 'packaged-48e34541-f296-4611-9073-74a403af39bd.txt'
    if os.path.exists(INDICATOR_FILE_NAME):
        print('Package has already ran... Skipping second packaging!')
        raise SystemExit()

    # Touch a file to make sure the script doesn't run again!
    with open(INDICATOR_FILE_NAME, 'a'):
        print('Adding marker so a future package command may be skipped!')
        os.utime(INDICATOR_FILE_NAME, None)


def parse_expected_http_port(filename='Dockerfile'):
    """
    Process input Dockerfile and derive the port of the http server.
    This is then used by the default liveness and readiness probes.

    TODO: look for a Dockerfile parser that enables access to EXPOSEd ports.
    """
    ports = [
        int(p) for l in open('Dockerfile').readlines()
        for p in l[len('EXPOSE '):].strip().split() if l.startswith('EXPOSE')
    ]
    port = None
    if not len(ports):
        print('No PORT Detected in Dockerfile: Using 8888')
        port = 8888
    else:
        m = f'Found exposed ports: {ports}; Using {ports[0]} for probes'
        print(m)
        port = ports[0]
    return port


def append_default_probes(port):
    """
    Append liveness checks if not present.

    See: https://k8s.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/ # noqa
    """
    defaults = {
        # The readinessProbe defines when your service is ready for traffic.
        'readinessProbe': {
            'httpGet': {
                'path': '/_wk/ready',
                'port': port,
            },
            'initialDelaySeconds': 10,
            'periodSeconds': 10,
            'timeoutSeconds': 10,
            'successThreshold': 1,
            'failureThreshold': 3,
        },
        # ...
        'livenessProbe': {
            'httpGet': {
                'path': '/_wk/alive',
                'port': port,
            },
            'initialDelaySeconds': 10,
            'periodSeconds': 10,
        }
    }

    for dirpath, _, filenames in os.walk(os.getcwd()):
        if 'values.yaml' not in filenames:
            continue
        file = os.sep.join([dirpath, 'values.yaml'])

        # Load the existing values.yaml
        values = None
        with open(file, 'r') as f:
            values = yaml.safe_load(f)

        # If values.yaml is empty, safe_load returns None
        if not values:
            values = {}

        # Append default top-level keys
        for key, value in defaults.items():
            if key not in values:
                values[key] = value

        # Dump updated file back to os
        with open(file, 'w') as f:
            yaml.safe_dump(values, f)


def main():
    """ Apply Workiva defaults to infrastructure stuff. """
    detect_if_we_have_run_package_before()
    print('Welcome to the Workiva Platform!')
    print('Building HELM Artifacts...')
    port = parse_expected_http_port()
    append_default_probes(port)
    sh.helm.package(sh.glob('helm/*'))
    print('DONE!')
    print('Your Service is now ready for Deployment through Release Pipelines')


if __name__ == '__main__':
    main()
